diff --git a/.changeset/mean-poets-go.md b/.changeset/mean-poets-go.md
new file mode 100644
index 00000000..a6b48b0a
--- /dev/null
+++ b/.changeset/mean-poets-go.md
@@ -0,0 +1,5 @@
+---
+"gradio": minor
+---
+
+feat:Unix socket support
diff --git a/gradio/blocks.py b/gradio/blocks.py
index 3dae5619..5a99ae76 100644
--- a/gradio/blocks.py
+++ b/gradio/blocks.py
@@ -25,7 +25,6 @@ from gradio_client import serializing
 from gradio_client import utils as client_utils
 from gradio_client.documentation import document, set_documentation_group
 from packaging import version
-import requests_unixsocket
 
 from gradio import (
     analytics,
@@ -38,6 +37,7 @@ from gradio import (
     themes,
     utils,
     wasm_utils,
+    requests_unixsocket,
 )
 from gradio.context import Context
 from gradio.deprecation import check_deprecated_parameters, warn_deprecation
@@ -2063,9 +2063,6 @@ Received outputs:
             self.is_colab = utils.colab_check()
             self.is_kaggle = utils.kaggle_check()
 
-            if self.local_url.startswith("http+unix"):
-                requests_unixsocket.monkeypatch()
-
             self.protocol = (
                 "https"
                 if self.local_url.startswith("https") or self.is_colab
@@ -2084,7 +2081,10 @@ Received outputs:
             if not wasm_utils.IS_WASM:
                 # Cannot run async functions in background other than app's scope.
                 # Workaround by triggering the app endpoint
-                requests.get(f"{self.local_url}startup-events", verify=ssl_verify)
+                session = requests.Session()
+                if self.local_url.startswith(requests_unixsocket.DEFAULT_SCHEME):
+                    session = requests_unixsocket.Session()
+                session.get(f"{self.local_url}startup-events", verify=ssl_verify)
             else:
                 # NOTE: One benefit of the code above dispatching `startup_events()` via a self HTTP request is
                 # that `self._queue.start()` is called in another thread which is managed by the HTTP server, `uvicorn`
diff --git a/gradio/networking.py b/gradio/networking.py
index 65724274..e3e5638d 100644
--- a/gradio/networking.py
+++ b/gradio/networking.py
@@ -20,7 +20,7 @@ from gradio.exceptions import ServerFailedToStartError
 from gradio.routes import App
 from gradio.tunneling import Tunnel
 from gradio.utils import SourceFileReloader, watchfn
-
+from gradio import requests_unixsocket
 if TYPE_CHECKING:  # Only import for type checking (to avoid circular imports).
     from gradio.blocks import Blocks
 
@@ -248,7 +248,10 @@ def url_ok(url: str) -> bool:
         for _ in range(5):
             with warnings.catch_warnings():
                 warnings.filterwarnings("ignore")
-                r = requests.head(url, timeout=3, verify=False)
+                session = requests.Session()
+                if url.startswith(requests_unixsocket.DEFAULT_SCHEME):
+                    session = requests_unixsocket.Session()
+                r = session.head(url, timeout=3, verify=False)
             if r.status_code in (200, 401, 302):  # 401 or 302 if auth is set
                 return True
             time.sleep(0.500)
diff --git a/gradio/requests_unixsocket.py b/gradio/requests_unixsocket.py
new file mode 100644
index 00000000..c8b6c643
--- /dev/null
+++ b/gradio/requests_unixsocket.py
@@ -0,0 +1,92 @@
+import socket
+
+from requests.adapters import HTTPAdapter
+from requests.compat import urlparse, unquote
+import requests
+
+try:
+    from requests.packages import urllib3
+except ImportError:
+    import urllib3
+
+DEFAULT_SCHEME = 'http+unix://'
+
+
+class Session(requests.Session):
+    def __init__(self, url_scheme=DEFAULT_SCHEME, *args, **kwargs):
+        super(Session, self).__init__(*args, **kwargs)
+        self.mount(url_scheme, UnixAdapter())
+
+
+# The following was adapted from some code from requests_unixsocket
+# https://github.com/msabramo/requests-unixsocket/blob/master/requests_unixsocket/adapters.py
+class UnixHTTPConnection(urllib3.connection.HTTPConnection, object):
+
+    def __init__(self, unix_socket_url, timeout=60):
+        """Create an HTTP connection to a unix domain socket
+
+        :param unix_socket_url: A URL with a scheme of 'http+unix' and the
+        netloc is a percent-encoded path to a unix domain socket. E.g.:
+        'http+unix://%2Ftmp%2Fprofilesvc.sock/status/pid'
+        """
+        super(UnixHTTPConnection, self).__init__('localhost', timeout=timeout)
+        self.unix_socket_url = unix_socket_url
+        self.timeout = timeout
+        self.sock = None
+
+    def __del__(self):  # base class does not have d'tor
+        if self.sock:
+            self.sock.close()
+
+    def connect(self):
+        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
+        sock.settimeout(self.timeout)
+        socket_path = unquote(urlparse(self.unix_socket_url).netloc)
+        sock.connect(socket_path)
+        self.sock = sock
+
+
+class UnixHTTPConnectionPool(urllib3.connectionpool.HTTPConnectionPool):
+
+    def __init__(self, socket_path, timeout=60):
+        super(UnixHTTPConnectionPool, self).__init__(
+            'localhost', timeout=timeout)
+        self.socket_path = socket_path
+        self.timeout = timeout
+
+    def _new_conn(self):
+        return UnixHTTPConnection(self.socket_path, self.timeout)
+
+
+class UnixAdapter(HTTPAdapter):
+
+    def __init__(self, timeout=60, pool_connections=25, *args, **kwargs):
+        super(UnixAdapter, self).__init__(*args, **kwargs)
+        self.timeout = timeout
+        self.pools = urllib3._collections.RecentlyUsedContainer(
+            pool_connections, dispose_func=lambda p: p.close()
+        )
+
+    def get_connection(self, url, proxies=None):
+        proxies = proxies or {}
+        proxy = proxies.get(urlparse(url.lower()).scheme)
+
+        if proxy:
+            raise ValueError('%s does not support specifying proxies'
+                             % self.__class__.__name__)
+
+        with self.pools.lock:
+            pool = self.pools.get(url)
+            if pool:
+                return pool
+
+            pool = UnixHTTPConnectionPool(url, self.timeout)
+            self.pools[url] = pool
+
+        return pool
+
+    def request_url(self, request, proxies):
+        return request.path_url
+
+    def close(self):
+        self.pools.clear()
\ No newline at end of file
diff --git a/test/test_networking.py b/test/test_networking.py
index e9c18a14..f8b02626 100644
--- a/test/test_networking.py
+++ b/test/test_networking.py
@@ -55,8 +55,8 @@ class TestInterfaceErrors:
 
 class TestStartServer:
     # Test IPv4 and IPv6 hostnames as they would be passed from --server-name.
-    @pytest.mark.parametrize("host", ["127.0.0.1", "[::1]"])
-    def test_start_server(self, host):
+    @pytest.mark.parametrize("host,scheme", [("127.0.0.1", "http"), ("[::1]", "http"), ("/tmp/test.socket", "http+unix")])
+    def test_start_server(self, host, scheme):
         io = Interface(lambda x: x, "number", "number")
         io.favicon_path = None
         io.config = io.get_config_file()
@@ -65,15 +65,24 @@ class TestStartServer:
         io.auth = None
         io.host = host
 
-        port = networking.get_first_available_port(
-            networking.INITIAL_PORT_VALUE,
-            networking.INITIAL_PORT_VALUE + networking.TRY_NUM_PORTS,
-        )
+        port = None
+        if scheme == "http":
+            port = networking.get_first_available_port(
+                networking.INITIAL_PORT_VALUE,
+                networking.INITIAL_PORT_VALUE + networking.TRY_NUM_PORTS,
+            )
         io.enable_queue = False
-        _, _, local_path, _, server = networking.start_server(io, server_port=port)
+        _, _, local_path, _, server = networking.start_server(io, server_port=port, server_name=host)
         url = urllib.parse.urlparse(local_path)
-        assert url.scheme == "http"
+        assert url.scheme == scheme
         assert url.port == port
+        if scheme == "http":
+            assert server.config.uds is None
+            assert server.config.host == host.replace("[", "").replace("]", "")
+        else:
+            assert server.config.uds == host
+            assert server.config.host is None
+
         server.close()
 
 
