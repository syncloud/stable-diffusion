diff --git a/gradio/blocks.py b/gradio/blocks.py
index 4b80c87b..1d2bbeda 100644
--- a/gradio/blocks.py
+++ b/gradio/blocks.py
@@ -25,6 +25,7 @@ from gradio_client import serializing
 from gradio_client import utils as client_utils
 from gradio_client.documentation import document, set_documentation_group
 from packaging import version
+import requests_unixsocket
 
 from gradio import (
     analytics,
@@ -2023,6 +2024,9 @@ Received outputs:
             self.is_colab = utils.colab_check()
             self.is_kaggle = utils.kaggle_check()
 
+            if self.local_url.startswith("http+unix"):
+                requests_unixsocket.monkeypatch()
+
             self.protocol = (
                 "https"
                 if self.local_url.startswith("https") or self.is_colab
diff --git a/gradio/networking.py b/gradio/networking.py
index b216f019..3af36508 100644
--- a/gradio/networking.py
+++ b/gradio/networking.py
@@ -156,6 +156,12 @@ def start_server(
 
     app = App.create_app(blocks, app_kwargs=app_kwargs)
 
+    uds = None
+    if host.startswith("/"):
+        uds = host
+        host = None
+        server_port = 0
+
     server_ports = (
         [server_port]
         if server_port is not None
@@ -164,15 +170,16 @@ def start_server(
 
     for port in server_ports:
         try:
-            # The fastest way to check if a port is available is to try to bind to it with socket.
-            # If the port is not available, socket will throw an OSError.
-            s = socket.socket()
-            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
-            # Really, we should be checking if (server_name, server_port) is available, but
-            # socket.bind() doesn't seem to throw an OSError with ipv6 addresses, based on my testing.
-            # Instead, we just check if the port is available on localhost.
-            s.bind((LOCALHOST_NAME, port))
-            s.close()
+            if host is not None:
+                # The fastest way to check if a port is available is to try to bind to it with socket.
+                # If the port is not available, socket will throw an OSError.
+                s = socket.socket()
+                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+                # Really, we should be checking if (server_name, server_port) is available, but
+                # socket.bind() doesn't seem to throw an OSError with ipv6 addresses, based on my testing.
+                # Instead, we just check if the port is available on localhost.
+                s.bind((LOCALHOST_NAME, port))
+                s.close()
 
             # To avoid race conditions, so we also check if the port by trying to start the uvicorn server.
             # If the port is not available, this will throw a ServerFailedToStartError.
@@ -180,6 +187,7 @@ def start_server(
                 app=app,
                 port=port,
                 host=host,
+                uds=uds,
                 log_level="warning",
                 ssl_keyfile=ssl_keyfile,
                 ssl_certfile=ssl_certfile,
@@ -213,6 +221,9 @@ def start_server(
     else:
         path_to_local_server = f"http://{url_host_name}:{port}/"
 
+    if host.startswith("/"):
+        path_to_local_server = "http+unix://" + host.replace("/", "%2F") + "/"
+
     return server_name, port, path_to_local_server, app, server
 
 
diff --git a/requirements.txt b/requirements.txt
index ce213543..b1558a54 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -22,4 +22,5 @@ requests~=2.0
 semantic_version~=2.0
 typing_extensions~=4.0
 uvicorn>=0.14.0
-websockets>=10.0,<12.0
\ No newline at end of file
+websockets>=10.0,<12.0
+requests-unixsocket==0.3.0
\ No newline at end of file
