diff --git a/.changeset/mean-poets-go.md b/.changeset/mean-poets-go.md
new file mode 100644
index 000000000..a6b48b0ad
--- /dev/null
+++ b/.changeset/mean-poets-go.md
@@ -0,0 +1,5 @@
+---
+"gradio": minor
+---
+
+feat:Unix socket support
diff --git a/gradio/blocks.py b/gradio/blocks.py
index afc3335e1..6a391b8c5 100644
--- a/gradio/blocks.py
+++ b/gradio/blocks.py
@@ -2080,7 +2080,10 @@ Received outputs:
             if not wasm_utils.IS_WASM:
                 # Cannot run async functions in background other than app's scope.
                 # Workaround by triggering the app endpoint
-                requests.get(f"{self.local_url}startup-events", verify=ssl_verify)
+                session = requests.Session()
+                if self.local_url.startswith(requests_unixsocket.DEFAULT_SCHEME):
+                    session = requests_unixsocket.Session()
+                session.get(f"{self.local_url}startup-events", verify=ssl_verify)
             else:
                 # NOTE: One benefit of the code above dispatching `startup_events()` via a self HTTP request is
                 # that `self._queue.start()` is called in another thread which is managed by the HTTP server, `uvicorn`
diff --git a/gradio/networking.py b/gradio/networking.py
index b216f0191..65724274b 100644
--- a/gradio/networking.py
+++ b/gradio/networking.py
@@ -156,6 +156,12 @@ def start_server(
 
     app = App.create_app(blocks, app_kwargs=app_kwargs)
 
+    uds = None
+    if host.startswith("/"):
+        uds = host
+        host = None
+        server_port = 0
+
     server_ports = (
         [server_port]
         if server_port is not None
@@ -164,15 +170,16 @@ def start_server(
 
     for port in server_ports:
         try:
-            # The fastest way to check if a port is available is to try to bind to it with socket.
-            # If the port is not available, socket will throw an OSError.
-            s = socket.socket()
-            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
-            # Really, we should be checking if (server_name, server_port) is available, but
-            # socket.bind() doesn't seem to throw an OSError with ipv6 addresses, based on my testing.
-            # Instead, we just check if the port is available on localhost.
-            s.bind((LOCALHOST_NAME, port))
-            s.close()
+            if host is not None:
+                # The fastest way to check if a port is available is to try to bind to it with socket.
+                # If the port is not available, socket will throw an OSError.
+                s = socket.socket()
+                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+                # Really, we should be checking if (server_name, server_port) is available, but
+                # socket.bind() doesn't seem to throw an OSError with ipv6 addresses, based on my testing.
+                # Instead, we just check if the port is available on localhost.
+                s.bind((LOCALHOST_NAME, port))
+                s.close()
 
             # To avoid race conditions, so we also check if the port by trying to start the uvicorn server.
             # If the port is not available, this will throw a ServerFailedToStartError.
@@ -180,6 +187,7 @@ def start_server(
                 app=app,
                 port=port,
                 host=host,
+                uds=uds,
                 log_level="warning",
                 ssl_keyfile=ssl_keyfile,
                 ssl_certfile=ssl_certfile,
@@ -213,6 +221,9 @@ def start_server(
     else:
         path_to_local_server = f"http://{url_host_name}:{port}/"
 
+    if server_name.startswith("/"):
+        path_to_local_server = "http+unix://" + server_name.replace("/", "%2F") + "/"
+
     return server_name, port, path_to_local_server, app, server
 
 
diff --git a/gradio/queueing.py b/gradio/queueing.py
index 5bcc51e1b..af4fdcb9c 100644
--- a/gradio/queueing.py
+++ b/gradio/queueing.py
@@ -355,9 +355,14 @@ class Queue:
             "url": str(websocket.url),
             "headers": dict(websocket.headers),
             "query_params": dict(websocket.query_params),
-            "path_params": dict(websocket.path_params),
-            "client": {"host": websocket.client.host, "port": websocket.client.port},  # type: ignore
+            "path_params": dict(websocket.path_params)
         }
+        if websocket.client:
+            params["client"] = {
+                "host": websocket.client.host,  # type: ignore
+                "port": websocket.client.port,  # type: ignore
+            }
+
         try:
             params[
                 "session"
diff --git a/gradio/requests_unixsocket.py b/gradio/requests_unixsocket.py
new file mode 100644
index 000000000..c8b6c6437
--- /dev/null
+++ b/gradio/requests_unixsocket.py
@@ -0,0 +1,92 @@
+import socket
+
+from requests.adapters import HTTPAdapter
+from requests.compat import urlparse, unquote
+import requests
+
+try:
+    from requests.packages import urllib3
+except ImportError:
+    import urllib3
+
+DEFAULT_SCHEME = 'http+unix://'
+
+
+class Session(requests.Session):
+    def __init__(self, url_scheme=DEFAULT_SCHEME, *args, **kwargs):
+        super(Session, self).__init__(*args, **kwargs)
+        self.mount(url_scheme, UnixAdapter())
+
+
+# The following was adapted from some code from requests_unixsocket
+# https://github.com/msabramo/requests-unixsocket/blob/master/requests_unixsocket/adapters.py
+class UnixHTTPConnection(urllib3.connection.HTTPConnection, object):
+
+    def __init__(self, unix_socket_url, timeout=60):
+        """Create an HTTP connection to a unix domain socket
+
+        :param unix_socket_url: A URL with a scheme of 'http+unix' and the
+        netloc is a percent-encoded path to a unix domain socket. E.g.:
+        'http+unix://%2Ftmp%2Fprofilesvc.sock/status/pid'
+        """
+        super(UnixHTTPConnection, self).__init__('localhost', timeout=timeout)
+        self.unix_socket_url = unix_socket_url
+        self.timeout = timeout
+        self.sock = None
+
+    def __del__(self):  # base class does not have d'tor
+        if self.sock:
+            self.sock.close()
+
+    def connect(self):
+        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
+        sock.settimeout(self.timeout)
+        socket_path = unquote(urlparse(self.unix_socket_url).netloc)
+        sock.connect(socket_path)
+        self.sock = sock
+
+
+class UnixHTTPConnectionPool(urllib3.connectionpool.HTTPConnectionPool):
+
+    def __init__(self, socket_path, timeout=60):
+        super(UnixHTTPConnectionPool, self).__init__(
+            'localhost', timeout=timeout)
+        self.socket_path = socket_path
+        self.timeout = timeout
+
+    def _new_conn(self):
+        return UnixHTTPConnection(self.socket_path, self.timeout)
+
+
+class UnixAdapter(HTTPAdapter):
+
+    def __init__(self, timeout=60, pool_connections=25, *args, **kwargs):
+        super(UnixAdapter, self).__init__(*args, **kwargs)
+        self.timeout = timeout
+        self.pools = urllib3._collections.RecentlyUsedContainer(
+            pool_connections, dispose_func=lambda p: p.close()
+        )
+
+    def get_connection(self, url, proxies=None):
+        proxies = proxies or {}
+        proxy = proxies.get(urlparse(url.lower()).scheme)
+
+        if proxy:
+            raise ValueError('%s does not support specifying proxies'
+                             % self.__class__.__name__)
+
+        with self.pools.lock:
+            pool = self.pools.get(url)
+            if pool:
+                return pool
+
+            pool = UnixHTTPConnectionPool(url, self.timeout)
+            self.pools[url] = pool
+
+        return pool
+
+    def request_url(self, request, proxies):
+        return request.path_url
+
+    def close(self):
+        self.pools.clear()
\ No newline at end of file
